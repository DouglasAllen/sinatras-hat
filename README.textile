h1. Sinatra's Hat

Mount models as web services in Sinatra with ease.

h2. Usage

The setup:

  %w(rubygems dm-core dm-serializer sinatra sinatras-hat).each { |lib| require lib }

  class Post
    include DataMapper::Resource
    include DataMapper::Serializer
    property :id, Serial, :key => true
    property :name, String
    property :body, Text
  end
  
  configure do
    DataMapper.setup(:default, 'sqlite3::memory:')
    Post.auto_migrate!
    Post.create :name => 'A test', :body => "Some sort of thing"
  end

The simplest use case:
  
  mount(Post)

This will generate the following routes:

* @GET  /posts/:id@
* @POST /posts/:id@
* @GET  /posts/:id@
* @PUT  /posts/:id@
* @DELETE /posts/:id@

h3. Rendering views

Whenever a request comes in to one of the generated routes, we look for a format. If we
can't find one, we look for a template file, which should be located in a subdirectory
of your app views directory named the same as your prefix. So the index.erb template
should be located in the views/posts directory.

h4. Sample App Directory:

  awesome-app/
    app.rb
    lib/
      comment.rb
      post.rb
    views/
      comments/
        edit.erb
        new.erb
        index.erb
        show.erb
      posts/
        edit.erb
        index.erb
        new.erb
        show.erb

h3. Mounting Options

Calling @mount(Post)@ generates index, show, update, and destroy routes for the Post model
using the prefix of "/posts". You can specify a different prefix to use with
the @:prefix@ option:

  mount Post, :prefix => :articles

If you only want to generate certain actions, you can use the @:only@ option. The following
will generate only show and index actions:

  mount Post, :only => [:show, :index]

The @mount@ method also takes a block, where you can specify options as well:

  mount Post do
    only :show, :index
  end

By default, Sinatra's Hat will work with a DataMapper model, but you can specify your own @finder@
and @record@ loaders. To make things work with ActiveRecord, you can do this:

  mount Post do
    finder { |params| find(:all) }
    record { |params| find(params[:id]) }
  end

The @finder@ and @record@ blocks will be instance_exec'd in the context of your classes.

h3. Accepting formats

You can add new formats that can be used to create/update record using the @accepts@ hash to
specify a proc to turn into an attributes hash:

  mount Post do
    accepts[:yaml] = proc { |string| YAML.load(string) }
  end

When a request comes in to @/posts.yaml@, the YAML handling proc will be called, and passed the
@params[:post]@ string. The value of that will be assigned to a new @Post@ object's attributes hash,
which is then saved.

h3. Response formats

You can register new response formats using the @formats@ option:

  mount Post do
    formats[:ruby] = proc { |result| result.inspect }
  end

Requests coming in with the format @.ruby@ will be processed by this proc. The other way to provide formats
is to just have a method defined by the model class that will convert for you (such as @to_json@ or @to_xml@).

h3. Authentication

You can protect certain actions using basic authentication using the @protect@ method. The
following snippet will make the @index@ and @show@ actions require authentication. You should
pass username and password options as well, unless you want to just use the defaults (admin:password):

  mount Post do
    protect :index, :show, :username => 'foo', :password => 'bar', :realm => 'MYPOSTS.com'
  end

If you want all of your actions to require authentication, you can simply pass @:all@ to @protect@:

  mount Post do
    protect :all, :username => 'foo', :password => 'bar', :realm => 'MYPOSTS.com'
  end

All of your actions will then require authentication.

h4. Custom Authentication Logic

Assuming you don't want to just verify username/password with the basic auth logic, you can use the #authenticator method to specify custom authentication logic:

  mount Post do
    protect :all
    authenticator { |username, password| User.authenticate(username, password) }
  end

h3. Mounting Child Resources

In Rails, you can mount child resources like so:

  map.resources :posts do |post|
    post.resources :comments
  end

With Sinatra's Hat, you just call @mount@ within a parent's @mount@ block:

  mount Post do
    mount Comment
  end

The child @mount@ call can take advantage of all the regular @mount@ options:

  mount Post do
    mount Comment do
      protect :destroy # only admins can destroy comments
    end
  end

You can keep mounting subresources until the cows come home:

  mount Post do
    mount Comment do
      mount Reply
    end
  end

h4. Install

  gem install nakajima-sinatras-hat --source=http://gems.github.com

"View the CI build":http://ci.patnakajima.com/sinatra-s-hat

h4. TODO

* Figure out better way to handle control flow (redirects vs. renders, etc.)

(c) Copyright 2008 Pat Nakajima. All Rights Reserved. 